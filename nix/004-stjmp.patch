diff --git a/Engine/corfiles.c b/Engine/corfiles.c
index 546bc381b..a531aa111 100644
--- a/Engine/corfiles.c
+++ b/Engine/corfiles.c
@@ -226,7 +226,7 @@ CORFIL *copy_to_corefile(CSOUND *csound, const char *fname,
     char buffer[1024];
     if (UNLIKELY(fname==NULL)) {
       csound->ErrorMsg(csound, Str("Null file name in copy_to_corefile"));
-      csound->LongJmp(csound, 1);
+      /* csound->LongJmp(csound, 1); */
     }
 #ifdef HAVE_CURL
     if (strstr(fname,"://")) {
diff --git a/Engine/csound_orc_compile.c b/Engine/csound_orc_compile.c
index 95bf43d0f..3d346475d 100644
--- a/Engine/csound_orc_compile.c
+++ b/Engine/csound_orc_compile.c
@@ -1921,13 +1921,7 @@ extern void sanitize(CSOUND *csound);
 int csoundCompileOrcInternal(CSOUND *csound, const char *str, int async) {
   TREE *root;
   int retVal = 1;
-  volatile jmp_buf tmpExitJmp;
 
-  memcpy((void *)&tmpExitJmp, (void *)&csound->exitjmp, sizeof(jmp_buf));
-  if ((retVal = setjmp(csound->exitjmp))) {
-    memcpy((void *)&csound->exitjmp, (void *)&tmpExitJmp, sizeof(jmp_buf));
-    return retVal;
-  }
   // retVal = 1;
   root = csoundParseOrc(csound, str);
   if (LIKELY(root != NULL)) {
@@ -1936,14 +1930,11 @@ int csoundCompileOrcInternal(CSOUND *csound, const char *str, int async) {
     sanitize(csound);
     csoundDeleteTree(csound, root);
   } else {
-    // csoundDeleteTree(csound, root);
-    memcpy((void *)&csound->exitjmp, (void *)&tmpExitJmp, sizeof(jmp_buf));
     return CSOUND_ERROR;
   }
 
   if (UNLIKELY(csound->oparms->odebug))
     debugPrintCsound(csound);
-  memcpy((void *)&csound->exitjmp, (void *)&tmpExitJmp, sizeof(jmp_buf));
   return retVal;
 }
 
diff --git a/Engine/linevent.c b/Engine/linevent.c
index cce339c1d..4c9b664f8 100644
--- a/Engine/linevent.c
+++ b/Engine/linevent.c
@@ -147,7 +147,6 @@ static inline int containsLF(char *cp, char *endp)
 
 static CS_NOINLINE int linevent_alloc(CSOUND *csound, int reallocsize)
 {
-    volatile jmp_buf tmpExitJmp;
     int         err;
     unsigned int tmp;
 
@@ -173,15 +172,8 @@ static CS_NOINLINE int linevent_alloc(CSOUND *csound, int reallocsize)
     //csound->Message(csound, "1. realloc: %d\n", reallocsize);
     if (STA(Linep)) return 0;
     csound->Linefd = -1;
-    memcpy((void*) &tmpExitJmp, (void*) &csound->exitjmp, sizeof(jmp_buf));
-    if ((err = setjmp(csound->exitjmp)) != 0) {
-      memcpy((void*) &csound->exitjmp, (void*) &tmpExitJmp, sizeof(jmp_buf));
-      //csound->lineventGlobals = NULL;
-      return -1;
-    }
 
 
-    memcpy((void*) &csound->exitjmp, (void*) &tmpExitJmp, sizeof(jmp_buf));
     STA(prve).opcod = ' ';
     STA(Linebufend) = STA(Linebuf) + STA(linebufsiz);
     STA(Linep) = STA(Linebuf);
diff --git a/OOps/bus.c b/OOps/bus.c
index 763154394..13a363df1 100644
--- a/OOps/bus.c
+++ b/OOps/bus.c
@@ -24,7 +24,6 @@
 
 /*                      BUS.C           */
 #include "csoundCore.h"
-#include <setjmp.h>
 #include <ctype.h>
 #include <string.h>
 #include <stdio.h>
diff --git a/Top/csmodule.c b/Top/csmodule.c
index 21381b9f0..2622cd2b3 100644
--- a/Top/csmodule.c
+++ b/Top/csmodule.c
@@ -73,7 +73,6 @@
 #include <stdlib.h>
 #include <string.h>
 #include <errno.h>
-#include <setjmp.h>
 
 #include "csoundCore.h"
 #include "csmodule.h"
@@ -239,7 +238,6 @@ static CS_NOINLINE int csoundLoadExternal(CSOUND *csound,
                                           const char *libraryPath)
 {
     csoundModule_t  m;
-    volatile jmp_buf tmpExitJmp;
     csoundModule_t  *mp;
     char            *fname;
     void            *h, *p;
@@ -352,16 +350,7 @@ static CS_NOINLINE int csoundLoadExternal(CSOUND *csound,
     csound->csmodule_db = (void*) mp;
     /* call csoundModuleCreate() if available */
     if (m.PreInitFunc != NULL) {
-      memcpy((void*) &tmpExitJmp, (void*) &csound->exitjmp, sizeof(jmp_buf));
-      if ((err = setjmp(csound->exitjmp)) != 0) {
-        memcpy((void*) &csound->exitjmp, (void*) &tmpExitJmp, sizeof(jmp_buf));
-        print_module_error(csound, Str("Error in pre-initialisation function "
-                                       "of module '%s'"), fname, NULL, 0);
-        return (err == (CSOUND_EXITJMP_SUCCESS + CSOUND_MEMORY) ?
-                CSOUND_MEMORY : CSOUND_INITIALIZATION);
-      }
       err = m.PreInitFunc(csound);
-      memcpy((void*) &csound->exitjmp, (void*) &tmpExitJmp, sizeof(jmp_buf));
       if (UNLIKELY(err != 0)) {
         print_module_error(csound, Str("Error in pre-initialisation function "
                                        "of module '%s'"), fname, &m, err);
@@ -674,22 +663,15 @@ int csoundInitModules(CSOUND *csound)
 
 int csoundLoadAndInitModule(CSOUND *csound, const char *fname)
 {
-    volatile jmp_buf  tmpExitJmp;
     volatile int      err;
 
     err = csoundLoadExternal(csound, fname);
     if (UNLIKELY(err != 0))
       return err;
-    memcpy((void*) &tmpExitJmp, (void*) &csound->exitjmp, sizeof(jmp_buf));
-    if (UNLIKELY((err = setjmp(csound->exitjmp)) != 0)) {
-      memcpy((void*) &csound->exitjmp, (void*) &tmpExitJmp, sizeof(jmp_buf));
-      return (err == (CSOUND_EXITJMP_SUCCESS + CSOUND_MEMORY) ?
-              CSOUND_MEMORY : CSOUND_INITIALIZATION);
-    }
+
     /* NOTE: this depends on csound->csmodule_db being the most recently */
     /* loaded plugin library */
     err = csoundInitModule(csound, (csoundModule_t*) csound->csmodule_db);
-    memcpy((void*) &csound->exitjmp, (void*) &tmpExitJmp, sizeof(jmp_buf));
 
     return err;
 }
diff --git a/Top/csound.c b/Top/csound.c
index 54386368f..bb6717886 100644
--- a/Top/csound.c
+++ b/Top/csound.c
@@ -1673,7 +1673,6 @@ int kperf_nodebug(CSOUND *csound)
     /* calls of csoundYield() */
     if (UNLIKELY(--(csound->evt_poll_cnt) < 0)) {
       csound->evt_poll_cnt = csound->evt_poll_maxcnt;
-      if (UNLIKELY(!csoundYield(csound))) csound->LongJmp(csound, 1);
     }
 
     /* for one kcnt: */
@@ -1732,45 +1731,45 @@ int kperf_nodebug(CSOUND *csound)
                 opstart = opstart->insdshead->pds;
               }
             } else {
-                int error = 0;
-                int i, n = csound->nspout, start = 0;
-                int lksmps = ip->ksmps;
-                int incr = csound->nchnls*lksmps;
-                int offset =  ip->ksmps_offset;
-                int early = ip->ksmps_no_end;
-                OPDS  *opstart;
-                ip->spin = csound->spin;
-                ip->spout = csound->spraw;
-                ip->kcounter =  csound->kcounter*csound->ksmps/lksmps;
-
-                /* we have to deal with sample-accurate code
-                   whole CS_KSMPS blocks are offset here, the
-                   remainder is left to each opcode to deal with.
-                */
-                while (offset >= lksmps) {
-                  offset -= lksmps;
-                  start += csound->nchnls;
-                }
-                ip->ksmps_offset = offset;
-                if (UNLIKELY(early)) {
-                  n -= (early*csound->nchnls);
-                  ip->ksmps_no_end = early % lksmps;
-                }
+              int error = 0;
+              int i, n = csound->nspout, start = 0;
+              int lksmps = ip->ksmps;
+              int incr = csound->nchnls*lksmps;
+              int offset =  ip->ksmps_offset;
+              int early = ip->ksmps_no_end;
+              OPDS  *opstart;
+              ip->spin = csound->spin;
+              ip->spout = csound->spraw;
+              ip->kcounter =  csound->kcounter*csound->ksmps/lksmps;
 
-                for (i=start; i < n; i+=incr, ip->spin+=incr, ip->spout+=incr) {
-                  opstart = (OPDS*) ip;
-                  while (error ==  0 && (opstart = opstart->nxtp) != NULL
-                         && ip->actflg) {
-                    opstart->insdshead->pds = opstart;
-                    error = (*opstart->opadr)(csound, opstart); /* run each opcode */
-                    opstart = opstart->insdshead->pds;
-                  }
-                  ip->kcounter++;
+              /* we have to deal with sample-accurate code
+                 whole CS_KSMPS blocks are offset here, the
+                 remainder is left to each opcode to deal with.
+              */
+              while (offset >= lksmps) {
+                offset -= lksmps;
+                start += csound->nchnls;
+              }
+              ip->ksmps_offset = offset;
+              if (UNLIKELY(early)) {
+                n -= (early*csound->nchnls);
+                ip->ksmps_no_end = early % lksmps;
+              }
+
+              for (i=start; i < n; i+=incr, ip->spin+=incr, ip->spout+=incr) {
+                opstart = (OPDS*) ip;
+                while (error ==  0 && (opstart = opstart->nxtp) != NULL
+                       && ip->actflg) {
+                  opstart->insdshead->pds = opstart;
+                  error = (*opstart->opadr)(csound, opstart); /* run each opcode */
+                  opstart = opstart->insdshead->pds;
                 }
+                ip->kcounter++;
+              }
             }
           }
           /*else csound->Message(csound, "time %f\n",
-                                 csound->kcounter/csound->ekr);*/
+            csound->kcounter/csound->ekr);*/
           ip->ksmps_offset = 0; /* reset sample-accuracy offset */
           ip->ksmps_no_end = 0; /* reset end of loop samples */
           ip = nxt; /* but this does not allow for all deletions */
@@ -1796,116 +1795,116 @@ int kperf_nodebug(CSOUND *csound)
 static inline void opcode_perf_debug(CSOUND *csound,
                                      csdebug_data_t *data, INSDS *ip)
 {
-    OPDS  *opstart = (OPDS*) ip;
-    while ((opstart = opstart->nxtp) != NULL) {
-        /* check if we have arrived at a line breakpoint */
-        bkpt_node_t *bp_node = data->bkpt_anchor->next;
-        if (data->debug_opcode_ptr) {
-          opstart = data->debug_opcode_ptr;
-          data->debug_opcode_ptr = NULL;
-        }
-        int linenum = opstart->optext->t.linenum;
-        while (bp_node) {
-          if (bp_node->instr == ip->p1.value || (bp_node->instr == 0)) {
-            if ((bp_node->line) == linenum) { /* line matches */
-              if (bp_node->count < 2) { /* skip of 0 or 1 has the same effect */
-                if (data->debug_opcode_ptr != opstart) { /* did we just stop here */
-                  data->debug_instr_ptr = ip;
-                  data->debug_opcode_ptr = opstart;
-                  data->status = CSDEBUG_STATUS_STOPPED;
-                  data->cur_bkpt = bp_node;
-                  csoundDebuggerBreakpointReached(csound);
-                  bp_node->count = bp_node->skip;
-                  return;
-                }
-                else {
-                  data->debug_opcode_ptr = NULL; /* if just stopped here-continue */
-                }
-              } else {
-                bp_node->count--;
-              }
+  OPDS  *opstart = (OPDS*) ip;
+  while ((opstart = opstart->nxtp) != NULL) {
+    /* check if we have arrived at a line breakpoint */
+    bkpt_node_t *bp_node = data->bkpt_anchor->next;
+    if (data->debug_opcode_ptr) {
+      opstart = data->debug_opcode_ptr;
+      data->debug_opcode_ptr = NULL;
+    }
+    int linenum = opstart->optext->t.linenum;
+    while (bp_node) {
+      if (bp_node->instr == ip->p1.value || (bp_node->instr == 0)) {
+        if ((bp_node->line) == linenum) { /* line matches */
+          if (bp_node->count < 2) { /* skip of 0 or 1 has the same effect */
+            if (data->debug_opcode_ptr != opstart) { /* did we just stop here */
+              data->debug_instr_ptr = ip;
+              data->debug_opcode_ptr = opstart;
+              data->status = CSDEBUG_STATUS_STOPPED;
+              data->cur_bkpt = bp_node;
+              csoundDebuggerBreakpointReached(csound);
+              bp_node->count = bp_node->skip;
+              return;
+            }
+            else {
+              data->debug_opcode_ptr = NULL; /* if just stopped here-continue */
             }
+          } else {
+            bp_node->count--;
           }
-          bp_node = bp_node->next;
         }
-      opstart->insdshead->pds = opstart;
-      (*opstart->opadr)(csound, opstart); /* run each opcode */
-      opstart = opstart->insdshead->pds;
+      }
+      bp_node = bp_node->next;
     }
+    opstart->insdshead->pds = opstart;
+    (*opstart->opadr)(csound, opstart); /* run each opcode */
+    opstart = opstart->insdshead->pds;
+  }
 }
 
 static inline void process_debug_buffers(CSOUND *csound, csdebug_data_t *data)
 {
-    bkpt_node_t *bkpt_node;
-    while (csoundReadCircularBuffer(csound,
-                                    data->bkpt_buffer, &bkpt_node, 1) == 1) {
-      if (bkpt_node->mode == CSDEBUG_BKPT_CLEAR_ALL) {
-        bkpt_node_t *n;
-        while (data->bkpt_anchor->next) {
-          n = data->bkpt_anchor->next;
-          data->bkpt_anchor->next = n->next;
+  bkpt_node_t *bkpt_node;
+  while (csoundReadCircularBuffer(csound,
+                                  data->bkpt_buffer, &bkpt_node, 1) == 1) {
+    if (bkpt_node->mode == CSDEBUG_BKPT_CLEAR_ALL) {
+      bkpt_node_t *n;
+      while (data->bkpt_anchor->next) {
+        n = data->bkpt_anchor->next;
+        data->bkpt_anchor->next = n->next;
+        csound->Free(csound, n); /* TODO this should be moved from kperf to a
+                                    non-realtime context */
+      }
+      csound->Free(csound, bkpt_node);
+    } else if (bkpt_node->mode == CSDEBUG_BKPT_DELETE) {
+      bkpt_node_t *n = data->bkpt_anchor->next;
+      bkpt_node_t *prev = data->bkpt_anchor;
+      while (n) {
+        if (n->line == bkpt_node->line && n->instr == bkpt_node->instr) {
+          prev->next = n->next;
           csound->Free(csound, n); /* TODO this should be moved from kperf to a
-                      non-realtime context */
+                                      non-realtime context */
+          n = prev->next;
+          continue;
         }
-        csound->Free(csound, bkpt_node);
-      } else if (bkpt_node->mode == CSDEBUG_BKPT_DELETE) {
-        bkpt_node_t *n = data->bkpt_anchor->next;
-        bkpt_node_t *prev = data->bkpt_anchor;
-        while (n) {
-          if (n->line == bkpt_node->line && n->instr == bkpt_node->instr) {
-            prev->next = n->next;
-            csound->Free(csound, n); /* TODO this should be moved from kperf to a
-                        non-realtime context */
-            n = prev->next;
-            continue;
-          }
-          prev = n;
-          n = n->next;
-        }
-//        csound->Free(csound, bkpt_node); /* TODO move to non rt context */
-      } else {
-          // FIXME sort list to optimize
-          bkpt_node->next = data->bkpt_anchor->next;
-          data->bkpt_anchor->next = bkpt_node;
+        prev = n;
+        n = n->next;
       }
+      //        csound->Free(csound, bkpt_node); /* TODO move to non rt context */
+    } else {
+      // FIXME sort list to optimize
+      bkpt_node->next = data->bkpt_anchor->next;
+      data->bkpt_anchor->next = bkpt_node;
     }
+  }
 }
 
 int kperf_debug(CSOUND *csound)
 {
-    INSDS *ip;
-    csdebug_data_t *data = (csdebug_data_t *) csound->csdebug_data;
+  INSDS *ip;
+  csdebug_data_t *data = (csdebug_data_t *) csound->csdebug_data;
 
-    /* call message_dequeue to run API calls */
-    message_dequeue(csound);
+  /* call message_dequeue to run API calls */
+  message_dequeue(csound);
 
-    if (!data || data->status != CSDEBUG_STATUS_STOPPED) {
-      /* update orchestra time */
-      csound->kcounter = ++(csound->global_kcounter);
-      csound->icurTime += csound->ksmps;
-      csound->curBeat += csound->curBeat_inc;
-    }
+  if (!data || data->status != CSDEBUG_STATUS_STOPPED) {
+    /* update orchestra time */
+    csound->kcounter = ++(csound->global_kcounter);
+    csound->icurTime += csound->ksmps;
+    csound->curBeat += csound->curBeat_inc;
+  }
 
-    /* if skipping time on request by 'a' score statement: */
-    if (UNLIKELY(csound->advanceCnt)) {
-      csound->advanceCnt--;
-      return 1;
-    }
-    /* if i-time only, return now */
-    if (UNLIKELY(csound->initonly))
-      return 1;
-    /* PC GUI needs attention, but avoid excessively frequent */
-    /* calls of csoundYield() */
-    if (UNLIKELY(--(csound->evt_poll_cnt) < 0)) {
-      csound->evt_poll_cnt = csound->evt_poll_maxcnt;
-      if (UNLIKELY(!csoundYield(csound))) csound->LongJmp(csound, 1);
-    }
+  /* if skipping time on request by 'a' score statement: */
+  if (UNLIKELY(csound->advanceCnt)) {
+    csound->advanceCnt--;
+    return 1;
+  }
+  /* if i-time only, return now */
+  if (UNLIKELY(csound->initonly))
+    return 1;
+  /* PC GUI needs attention, but avoid excessively frequent */
+  /* calls of csoundYield() */
+  if (UNLIKELY(--(csound->evt_poll_cnt) < 0)) {
+    csound->evt_poll_cnt = csound->evt_poll_maxcnt;
+    csoundYield(csound);
+  }
 
-    if (data) { /* process debug commands*/
-      process_debug_buffers(csound, data);
-    }
+  if (data) { /* process debug commands*/
+    process_debug_buffers(csound, data);
+  }
 
-    if (!data || data->status == CSDEBUG_STATUS_RUNNING)
+  if (!data || data->status == CSDEBUG_STATUS_RUNNING)
     {
       /* for one kcnt: */
       if (csound->oparms_.sfread)         /*   if audio_infile open  */
@@ -1916,355 +1915,331 @@ int kperf_debug(CSOUND *csound)
       memset(csound->spraw, 0, csound->nspout*sizeof(MYFLT));
     }
 
-    ip = csound->actanchor.nxtact;
-    /* Process debugger commands */
-    debug_command_t command = CSDEBUG_CMD_NONE;
-    if (data) {
-      csoundReadCircularBuffer(csound, data->cmd_buffer, &command, 1);
-      if (command == CSDEBUG_CMD_STOP && data->status != CSDEBUG_STATUS_STOPPED) {
-        data->debug_instr_ptr = ip;
-        data->status = CSDEBUG_STATUS_STOPPED;
-        csoundDebuggerBreakpointReached(csound);
-      }
-      if (command == CSDEBUG_CMD_CONTINUE &&
-          data->status == CSDEBUG_STATUS_STOPPED) {
-        if (data->cur_bkpt->skip <= 2) data->cur_bkpt->count = 2;
-        data->status = CSDEBUG_STATUS_RUNNING;
-        if (data->debug_instr_ptr) {
-          /* if not NULL, resume from last active */
-          ip = data->debug_instr_ptr;
-          data->debug_instr_ptr = NULL;
-        }
-      }
-      if (command == CSDEBUG_CMD_NEXT && data->status == CSDEBUG_STATUS_STOPPED) {
-          data->status = CSDEBUG_STATUS_NEXT;
+  ip = csound->actanchor.nxtact;
+  /* Process debugger commands */
+  debug_command_t command = CSDEBUG_CMD_NONE;
+  if (data) {
+    csoundReadCircularBuffer(csound, data->cmd_buffer, &command, 1);
+    if (command == CSDEBUG_CMD_STOP && data->status != CSDEBUG_STATUS_STOPPED) {
+      data->debug_instr_ptr = ip;
+      data->status = CSDEBUG_STATUS_STOPPED;
+      csoundDebuggerBreakpointReached(csound);
+    }
+    if (command == CSDEBUG_CMD_CONTINUE &&
+        data->status == CSDEBUG_STATUS_STOPPED) {
+      if (data->cur_bkpt->skip <= 2) data->cur_bkpt->count = 2;
+      data->status = CSDEBUG_STATUS_RUNNING;
+      if (data->debug_instr_ptr) {
+        /* if not NULL, resume from last active */
+        ip = data->debug_instr_ptr;
+        data->debug_instr_ptr = NULL;
       }
     }
-    if (ip != NULL && data != NULL && (data->status != CSDEBUG_STATUS_STOPPED) ) {
-      /* There are 2 partitions of work: 1st by inso,
-         2nd by inso count / thread count. */
-      if (csound->multiThreadedThreadInfo != NULL) {
-        if (csound->dag_changed) dag_build(csound, ip);
-        else dag_reinit(csound);     /* set to initial state */
-
-        /* process this partition */
-        csound->WaitBarrier(csound->barrier1);
+    if (command == CSDEBUG_CMD_NEXT && data->status == CSDEBUG_STATUS_STOPPED) {
+      data->status = CSDEBUG_STATUS_NEXT;
+    }
+  }
+  if (ip != NULL && data != NULL && (data->status != CSDEBUG_STATUS_STOPPED) ) {
+    /* There are 2 partitions of work: 1st by inso,
+       2nd by inso count / thread count. */
+    if (csound->multiThreadedThreadInfo != NULL) {
+      if (csound->dag_changed) dag_build(csound, ip);
+      else dag_reinit(csound);     /* set to initial state */
+
+      /* process this partition */
+      csound->WaitBarrier(csound->barrier1);
 
-        (void) nodePerf(csound, 0, 1);
+      (void) nodePerf(csound, 0, 1);
 
-        /* wait until partition is complete */
-        csound->WaitBarrier(csound->barrier2);
-        csound->multiThreadedDag = NULL;
-      }
-      else {
-        int done;
-        double time_end = (csound->ksmps+csound->icurTime)/csound->esr;
-
-        while (ip != NULL) {                /* for each instr active:  */
-          if (UNLIKELY(csound->oparms->sampleAccurate &&
-                       ip->offtim > 0                 &&
-                       time_end > ip->offtim)) {
-            /* this is the last cycle of performance */
-            //   csound->Message(csound, "last cycle %d: %f %f %d\n",
-            //       ip->insno, csound->icurTime/csound->esr,
-            //          ip->offtim, ip->no_end);
-            ip->ksmps_no_end = ip->no_end;
-          }
-          done = ATOMIC_GET(ip->init_done);
-          if (done == 1) {/* if init-pass has been done */
-            /* check if next command pending and we are on the
-               first instrument in the chain */
-            /* coverity says data already dereferenced by here */
-            if (/*data &&*/  data->status == CSDEBUG_STATUS_NEXT) {
-                if (data->debug_instr_ptr == NULL) {
-                    data->debug_instr_ptr = ip;
-                    data->debug_opcode_ptr = NULL;
-                    data->status = CSDEBUG_STATUS_STOPPED;
-                    csoundDebuggerBreakpointReached(csound);
-                    return 0;
-                } else {
-                    ip = data->debug_instr_ptr;
-                    data->debug_instr_ptr = NULL;
-                }
+      /* wait until partition is complete */
+      csound->WaitBarrier(csound->barrier2);
+      csound->multiThreadedDag = NULL;
+    }
+    else {
+      int done;
+      double time_end = (csound->ksmps+csound->icurTime)/csound->esr;
+
+      while (ip != NULL) {                /* for each instr active:  */
+        if (UNLIKELY(csound->oparms->sampleAccurate &&
+                     ip->offtim > 0                 &&
+                     time_end > ip->offtim)) {
+          /* this is the last cycle of performance */
+          //   csound->Message(csound, "last cycle %d: %f %f %d\n",
+          //       ip->insno, csound->icurTime/csound->esr,
+          //          ip->offtim, ip->no_end);
+          ip->ksmps_no_end = ip->no_end;
+        }
+        done = ATOMIC_GET(ip->init_done);
+        if (done == 1) {/* if init-pass has been done */
+          /* check if next command pending and we are on the
+             first instrument in the chain */
+          /* coverity says data already dereferenced by here */
+          if (/*data &&*/  data->status == CSDEBUG_STATUS_NEXT) {
+            if (data->debug_instr_ptr == NULL) {
+              data->debug_instr_ptr = ip;
+              data->debug_opcode_ptr = NULL;
+              data->status = CSDEBUG_STATUS_STOPPED;
+              csoundDebuggerBreakpointReached(csound);
+              return 0;
+            } else {
+              ip = data->debug_instr_ptr;
+              data->debug_instr_ptr = NULL;
             }
-            /* check if we have arrived at an instrument breakpoint */
-            bkpt_node_t *bp_node = data->bkpt_anchor->next;
-            while (bp_node && data->status != CSDEBUG_STATUS_NEXT) {
-              if (bp_node->instr == ip->p1.value && (bp_node->line == -1) ) {
-                if (bp_node->count < 2) {
-                  /* skip of 0 or 1 has the same effect */
-                  data->debug_instr_ptr = ip;
-                  data->debug_opcode_ptr = NULL;
-                  data->cur_bkpt = bp_node;
-                  data->status = CSDEBUG_STATUS_STOPPED;
-                  csoundDebuggerBreakpointReached(csound);
-                  bp_node->count = bp_node->skip;
-                  return 0;
-                } else {
-                  bp_node->count--;
-                }
+          }
+          /* check if we have arrived at an instrument breakpoint */
+          bkpt_node_t *bp_node = data->bkpt_anchor->next;
+          while (bp_node && data->status != CSDEBUG_STATUS_NEXT) {
+            if (bp_node->instr == ip->p1.value && (bp_node->line == -1) ) {
+              if (bp_node->count < 2) {
+                /* skip of 0 or 1 has the same effect */
+                data->debug_instr_ptr = ip;
+                data->debug_opcode_ptr = NULL;
+                data->cur_bkpt = bp_node;
+                data->status = CSDEBUG_STATUS_STOPPED;
+                csoundDebuggerBreakpointReached(csound);
+                bp_node->count = bp_node->skip;
+                return 0;
+              } else {
+                bp_node->count--;
               }
-              bp_node = bp_node->next;
             }
+            bp_node = bp_node->next;
+          }
+          ip->spin = csound->spin;
+          ip->spout = csound->spraw;
+          ip->kcounter =  csound->kcounter;
+          if (ip->ksmps == csound->ksmps) {
+            opcode_perf_debug(csound, data, ip);
+          } else { /* when instrument has local ksmps */
+            int i, n = csound->nspout, start = 0;
+            int lksmps = ip->ksmps;
+            int incr = csound->nchnls*lksmps;
+            int offset =  ip->ksmps_offset;
+            int early = ip->ksmps_no_end;
             ip->spin = csound->spin;
             ip->spout = csound->spraw;
-            ip->kcounter =  csound->kcounter;
-            if (ip->ksmps == csound->ksmps) {
-                opcode_perf_debug(csound, data, ip);
-            } else { /* when instrument has local ksmps */
-              int i, n = csound->nspout, start = 0;
-              int lksmps = ip->ksmps;
-              int incr = csound->nchnls*lksmps;
-              int offset =  ip->ksmps_offset;
-              int early = ip->ksmps_no_end;
-              ip->spin = csound->spin;
-              ip->spout = csound->spraw;
-              ip->kcounter =  csound->kcounter*csound->ksmps/lksmps;
+            ip->kcounter =  csound->kcounter*csound->ksmps/lksmps;
 
-              /* we have to deal with sample-accurate code
-                   whole CS_KSMPS blocks are offset here, the
-                   remainder is left to each opcode to deal with.
-                */
-              while (offset >= lksmps) {
-                offset -= lksmps;
-                start += csound->nchnls;
-              }
-              ip->ksmps_offset = offset;
-              if (UNLIKELY(early)) {
-                n -= (early*csound->nchnls);
-                ip->ksmps_no_end = early % lksmps;
-              }
+            /* we have to deal with sample-accurate code
+               whole CS_KSMPS blocks are offset here, the
+               remainder is left to each opcode to deal with.
+            */
+            while (offset >= lksmps) {
+              offset -= lksmps;
+              start += csound->nchnls;
+            }
+            ip->ksmps_offset = offset;
+            if (UNLIKELY(early)) {
+              n -= (early*csound->nchnls);
+              ip->ksmps_no_end = early % lksmps;
+            }
 
-              for (i=start; i < n; i+=incr, ip->spin+=incr, ip->spout+=incr) {
-                  opcode_perf_debug(csound, data, ip);
-                  ip->kcounter++;
-                }
+            for (i=start; i < n; i+=incr, ip->spin+=incr, ip->spout+=incr) {
+              opcode_perf_debug(csound, data, ip);
+              ip->kcounter++;
             }
           }
-          ip->ksmps_offset = 0; /* reset sample-accuracy offset */
-          ip->ksmps_no_end = 0;  /* reset end of loop samples */
-          ip = ip->nxtact; /* but this does not allow for all deletions */
-          if (/*data &&*/ data->status == CSDEBUG_STATUS_NEXT) {
-            data->debug_instr_ptr = ip; /* we have reached the next
-                                           instrument. Break */
-            data->debug_opcode_ptr = NULL;
-            if (ip != NULL) { /* must defer break until next kperf */
-              data->status = CSDEBUG_STATUS_STOPPED;
-              csoundDebuggerBreakpointReached(csound);
-              return 0;
-            }
+        }
+        ip->ksmps_offset = 0; /* reset sample-accuracy offset */
+        ip->ksmps_no_end = 0;  /* reset end of loop samples */
+        ip = ip->nxtact; /* but this does not allow for all deletions */
+        if (/*data &&*/ data->status == CSDEBUG_STATUS_NEXT) {
+          data->debug_instr_ptr = ip; /* we have reached the next
+                                         instrument. Break */
+          data->debug_opcode_ptr = NULL;
+          if (ip != NULL) { /* must defer break until next kperf */
+            data->status = CSDEBUG_STATUS_STOPPED;
+            csoundDebuggerBreakpointReached(csound);
+            return 0;
           }
         }
       }
     }
+  }
 
-    if (!data || data->status != CSDEBUG_STATUS_STOPPED)
+  if (!data || data->status != CSDEBUG_STATUS_STOPPED)
     {
-    if (!csound->spoutactive) {             /*   results now in spout? */
-      memset(csound->spout, 0, csound->nspout * sizeof(MYFLT));
-      memset(csound->spraw, 0, csound->nspout * sizeof(MYFLT));
-    }
-    else
-      make_interleave(csound);
-    csound->spoutran(csound);               /*      send to audio_out  */
+      if (!csound->spoutactive) {             /*   results now in spout? */
+        memset(csound->spout, 0, csound->nspout * sizeof(MYFLT));
+        memset(csound->spraw, 0, csound->nspout * sizeof(MYFLT));
+      }
+      else
+        make_interleave(csound);
+      csound->spoutran(csound);               /*      send to audio_out  */
     }
-    return 0;
+  return 0;
 }
 
 
 int csoundReadScoreInternal(CSOUND *csound, const char *str)
 {
-    OPARMS  *O = csound->oparms;
-     /* protect resource */
-    if (csound->scorestr != NULL &&
-       csound->scorestr->body != NULL)
-      corfile_rewind(csound->scorestr);
-    csound->scorestr = corfile_create_w(csound);
-    corfile_puts(csound, (char *)str, csound->scorestr);
-    //#ifdef SCORE_PARSER
-    if (csound->engineStatus&CS_STATE_COMP)
-      corfile_puts(csound, "\n#exit\n", csound->scorestr);
-    else
-      corfile_puts(csound, "\ne\n#exit\n", csound->scorestr);
-    //#endif
-    corfile_flush(csound, csound->scorestr);
-    /* copy sorted score name */
-    if (csound->scstr == NULL && (csound->engineStatus & CS_STATE_COMP) == 0) {
-      scsortstr(csound, csound->scorestr);
-      O->playscore = csound->scstr;
-      //corfile_rm(csound, &(csound->scorestr));
-      //printf("%s\n", O->playscore->body);
-    }
-    else {
-      char *sc = scsortstr(csound, csound->scorestr);
-      //printf("%s\n", sc);
-      csoundInputMessageInternal(csound, (const char *) sc);
-      csound->Free(csound, sc);
-      corfile_rm(csound, &(csound->scorestr));
-    }
-    return CSOUND_SUCCESS;
+  OPARMS  *O = csound->oparms;
+  /* protect resource */
+  if (csound->scorestr != NULL &&
+      csound->scorestr->body != NULL)
+    corfile_rewind(csound->scorestr);
+  csound->scorestr = corfile_create_w(csound);
+  corfile_puts(csound, (char *)str, csound->scorestr);
+  //#ifdef SCORE_PARSER
+  if (csound->engineStatus&CS_STATE_COMP)
+    corfile_puts(csound, "\n#exit\n", csound->scorestr);
+  else
+    corfile_puts(csound, "\ne\n#exit\n", csound->scorestr);
+  //#endif
+  corfile_flush(csound, csound->scorestr);
+  /* copy sorted score name */
+  if (csound->scstr == NULL && (csound->engineStatus & CS_STATE_COMP) == 0) {
+    scsortstr(csound, csound->scorestr);
+    O->playscore = csound->scstr;
+    //corfile_rm(csound, &(csound->scorestr));
+    //printf("%s\n", O->playscore->body);
+  }
+  else {
+    char *sc = scsortstr(csound, csound->scorestr);
+    //printf("%s\n", sc);
+    csoundInputMessageInternal(csound, (const char *) sc);
+    csound->Free(csound, sc);
+    corfile_rm(csound, &(csound->scorestr));
+  }
+  return CSOUND_SUCCESS;
 }
 
 
 PUBLIC int csoundPerformKsmps(CSOUND *csound)
 {
-    int done;
-    /* VL: 1.1.13 if not compiled (csoundStart() not called)  */
-    if (UNLIKELY(!(csound->engineStatus & CS_STATE_COMP))) {
-      csound->Warning(csound,
-                      Str("Csound not ready for performance: csoundStart() "
-                          "has not been called\n"));
-      return CSOUND_ERROR;
-    }
-    if (csound->jumpset == 0) {
-      int returnValue;
-      csound->jumpset = 1;
-      /* setup jmp for return after an exit() */
-      if (UNLIKELY((returnValue = setjmp(csound->exitjmp))))
-        return ((returnValue - CSOUND_EXITJMP_SUCCESS) | CSOUND_EXITJMP_SUCCESS);
+  int done;
+  /* VL: 1.1.13 if not compiled (csoundStart() not called)  */
+  if (UNLIKELY(!(csound->engineStatus & CS_STATE_COMP))) {
+    csound->Warning(csound,
+                    Str("Csound not ready for performance: csoundStart() "
+                        "has not been called\n"));
+    return CSOUND_ERROR;
+  }
+
+  if(!csound->oparms->realtime) // no API lock in realtime mode
+    csoundLockMutex(csound->API_lock);
+  do {
+    done = sensevents(csound);
+    if (UNLIKELY(done)) {
+      if(!csound->oparms->realtime) // no API lock in realtime mode
+        csoundUnlockMutex(csound->API_lock);
+      csoundMessage(csound,
+                    Str("Score finished in csoundPerformKsmps() with %d.\n"),
+                    done);
+      return done;
     }
-    if(!csound->oparms->realtime) // no API lock in realtime mode
-      csoundLockMutex(csound->API_lock);
-    do {
-      done = sensevents(csound);
-      if (UNLIKELY(done)) {
-        if(!csound->oparms->realtime) // no API lock in realtime mode
-         csoundUnlockMutex(csound->API_lock);
-        csoundMessage(csound,
-                      Str("Score finished in csoundPerformKsmps() with %d.\n"),
-                      done);
-        return done;
-      }
-    } while (csound->kperf(csound));
-    if(!csound->oparms->realtime) // no API lock in realtime mode
-       csoundUnlockMutex(csound->API_lock);
-    return 0;
+  } while (csound->kperf(csound));
+  if(!csound->oparms->realtime) // no API lock in realtime mode
+    csoundUnlockMutex(csound->API_lock);
+  return 0;
 }
 
 static int csoundPerformKsmpsInternal(CSOUND *csound)
 {
-    int done;
-    int returnValue;
+  int done;
+  int returnValue;
 
-    /* VL: 1.1.13 if not compiled (csoundStart() not called)  */
-    if (UNLIKELY(!(csound->engineStatus & CS_STATE_COMP))) {
-      csound->Warning(csound,
-                      Str("Csound not ready for performance: csoundStart() "
-                          "has not been called\n"));
-      return CSOUND_ERROR;
-    }
-    /* setup jmp for return after an exit() */
-        if (UNLIKELY((returnValue = setjmp(csound->exitjmp)))) {
-#ifndef MACOSX
-      csoundMessage(csound, Str("Early return from csoundPerformKsmps().\n"));
-#endif
-      return ((returnValue - CSOUND_EXITJMP_SUCCESS) | CSOUND_EXITJMP_SUCCESS);
+  /* VL: 1.1.13 if not compiled (csoundStart() not called)  */
+  if (UNLIKELY(!(csound->engineStatus & CS_STATE_COMP))) {
+    csound->Warning(csound,
+                    Str("Csound not ready for performance: csoundStart() "
+                        "has not been called\n"));
+    return CSOUND_ERROR;
+  }
+  /* setup jmp for return after an exit() */
+  do {
+    if (UNLIKELY((done = sensevents(csound)))) {
+      csoundMessage(csound,
+                    Str("Score finished in csoundPerformKsmpsInternal().\n"));
+      return done;
     }
-   do {
-     if (UNLIKELY((done = sensevents(csound)))) {
-       csoundMessage(csound,
-                     Str("Score finished in csoundPerformKsmpsInternal().\n"));
-        return done;
-      }
-    } while (csound->kperf(csound));
-    return 0;
+  } while (csound->kperf(csound));
+  return 0;
 }
 
 /* external host's outbuffer passed in csoundPerformBuffer() */
 PUBLIC int csoundPerformBuffer(CSOUND *csound)
 {
-    int returnValue;
-    int done;
-    /* VL: 1.1.13 if not compiled (csoundStart() not called)  */
-    if (UNLIKELY(!(csound->engineStatus & CS_STATE_COMP))) {
-      csound->Warning(csound,
-                      Str("Csound not ready for performance: csoundStart() "
-                          "has not been called\n"));
-      return CSOUND_ERROR;
-    }
-    /* Setup jmp for return after an exit(). */
-    if (UNLIKELY((returnValue = setjmp(csound->exitjmp)))) {
-#ifndef MACOSX
-      csoundMessage(csound, Str("Early return from csoundPerformBuffer().\n"));
-#endif
-      return ((returnValue - CSOUND_EXITJMP_SUCCESS) | CSOUND_EXITJMP_SUCCESS);
-    }
-    csound->sampsNeeded += csound->oparms_.outbufsamps;
-    while (csound->sampsNeeded > 0) {
-     if(!csound->oparms->realtime) {// no API lock in realtime mode
+  int returnValue;
+  int done;
+  /* VL: 1.1.13 if not compiled (csoundStart() not called)  */
+  if (UNLIKELY(!(csound->engineStatus & CS_STATE_COMP))) {
+    csound->Warning(csound,
+                    Str("Csound not ready for performance: csoundStart() "
+                        "has not been called\n"));
+    return CSOUND_ERROR;
+  }
+  /* Setup jmp for return after an exit(). */
+  csound->sampsNeeded += csound->oparms_.outbufsamps;
+  while (csound->sampsNeeded > 0) {
+    if(!csound->oparms->realtime) {// no API lock in realtime mode
       csoundLockMutex(csound->API_lock);
-     }
-      do {
-        if (UNLIKELY((done = sensevents(csound)))){
-          if(!csound->oparms->realtime) // no API lock in realtime mode
-            csoundUnlockMutex(csound->API_lock);
-          return done;
-        }
-      } while (csound->kperf(csound));
-      if(!csound->oparms->realtime) { // no API lock in realtime mode
-       csoundUnlockMutex(csound->API_lock);
+    }
+    do {
+      if (UNLIKELY((done = sensevents(csound)))){
+        if(!csound->oparms->realtime) // no API lock in realtime mode
+          csoundUnlockMutex(csound->API_lock);
+        return done;
       }
-      csound->sampsNeeded -= csound->nspout;
+    } while (csound->kperf(csound));
+    if(!csound->oparms->realtime) { // no API lock in realtime mode
+      csoundUnlockMutex(csound->API_lock);
     }
-    return 0;
+    csound->sampsNeeded -= csound->nspout;
+  }
+  return 0;
 }
 
 /* perform an entire score */
 
 PUBLIC int csoundPerform(CSOUND *csound)
 {
-    int done;
-    int returnValue;
+  int done;
+  int returnValue;
 
-   /* VL: 1.1.13 if not compiled (csoundStart() not called)  */
-    if (UNLIKELY(!(csound->engineStatus & CS_STATE_COMP))) {
-      csound->Warning(csound,
-                      Str("Csound not ready for performance: csoundStart() "
-                          "has not been called\n"));
-      return CSOUND_ERROR;
-    }
+  /* VL: 1.1.13 if not compiled (csoundStart() not called)  */
+  if (UNLIKELY(!(csound->engineStatus & CS_STATE_COMP))) {
+    csound->Warning(csound,
+                    Str("Csound not ready for performance: csoundStart() "
+                        "has not been called\n"));
+    return CSOUND_ERROR;
+  }
 
-    csound->performState = 0;
-    /* setup jmp for return after an exit() */
-    if (UNLIKELY((returnValue = setjmp(csound->exitjmp)))) {
-#ifndef MACOSX
-      csoundMessage(csound, Str("Early return from csoundPerform().\n"));
-#endif
-      return ((returnValue - CSOUND_EXITJMP_SUCCESS) | CSOUND_EXITJMP_SUCCESS);
-    }
+  csound->performState = 0;
+  /* setup jmp for return after an exit() */
+  do {
+    if(!csound->oparms->realtime)
+      csoundLockMutex(csound->API_lock);
     do {
+      if (UNLIKELY((done = sensevents(csound)))) {
+        csoundMessage(csound, Str("Score finished in csoundPerform().\n"));
         if(!csound->oparms->realtime)
-           csoundLockMutex(csound->API_lock);
-      do {
-        if (UNLIKELY((done = sensevents(csound)))) {
-          csoundMessage(csound, Str("Score finished in csoundPerform().\n"));
-          if(!csound->oparms->realtime)
           csoundUnlockMutex(csound->API_lock);
-          if (csound->oparms->numThreads > 1) {
-            csound->multiThreadedComplete = 1;
-            csound->WaitBarrier(csound->barrier1);
-          }
-          return done;
+        if (csound->oparms->numThreads > 1) {
+          csound->multiThreadedComplete = 1;
+          csound->WaitBarrier(csound->barrier1);
         }
-      } while (csound->kperf(csound));
-      if(!csound->oparms->realtime)
+        return done;
+      }
+    } while (csound->kperf(csound));
+    if(!csound->oparms->realtime)
       csoundUnlockMutex(csound->API_lock);
-    } while ((unsigned char) csound->performState == (unsigned char) '\0');
-    csoundMessage(csound, Str("csoundPerform(): stopped.\n"));
-    csound->performState = 0;
-    return 0;
+  } while ((unsigned char) csound->performState == (unsigned char) '\0');
+  csoundMessage(csound, Str("csoundPerform(): stopped.\n"));
+  csound->performState = 0;
+  return 0;
 }
 
 /* stop a csoundPerform() running in another thread */
 
 PUBLIC void *csoundGetNamedGens(CSOUND *csound)
 {
-    return csound->namedgen;
+  return csound->namedgen;
 }
 
 PUBLIC void csoundStop(CSOUND *csound)
 {
-    csound->performState = -1;
+  csound->performState = -1;
 }
 
 /*
@@ -2277,22 +2252,22 @@ PUBLIC int64_t csoundGetCurrentTimeSamples(CSOUND *csound){
 
 PUBLIC MYFLT csoundGetSr(CSOUND *csound)
 {
-    return csound->esr;
+  return csound->esr;
 }
 
 PUBLIC MYFLT csoundGetKr(CSOUND *csound)
 {
-    return csound->ekr;
+  return csound->ekr;
 }
 
 PUBLIC uint32_t csoundGetKsmps(CSOUND *csound)
 {
-    return csound->ksmps;
+  return csound->ksmps;
 }
 
 PUBLIC uint32_t csoundGetNchnls(CSOUND *csound)
 {
-    return csound->nchnls;
+  return csound->nchnls;
 }
 
 PUBLIC uint32_t csoundGetNchnlsInput(CSOUND *csound)
@@ -2304,29 +2279,29 @@ PUBLIC uint32_t csoundGetNchnlsInput(CSOUND *csound)
 
 PUBLIC MYFLT csoundGet0dBFS(CSOUND *csound)
 {
-    return csound->e0dbfs;
+  return csound->e0dbfs;
 }
 
 PUBLIC long csoundGetInputBufferSize(CSOUND *csound)
 {
-    return csound->oparms_.inbufsamps;
+  return csound->oparms_.inbufsamps;
 }
 
 PUBLIC long csoundGetOutputBufferSize(CSOUND *csound)
 {
-    return csound->oparms_.outbufsamps;
+  return csound->oparms_.outbufsamps;
 }
 
 PUBLIC MYFLT *csoundGetSpin(CSOUND *csound)
 {
-    return csound->spin;
+  return csound->spin;
 }
 
 PUBLIC void csoundSetSpinSample(CSOUND *csound, int frame,
                                 int channel, MYFLT sample)
 {
-    int index = (frame * csound->inchnls) + channel;
-    csound->spin[index] = sample;
+  int index = (frame * csound->inchnls) + channel;
+  csound->spin[index] = sample;
 }
 
 PUBLIC void csoundClearSpin(CSOUND *csound) {
@@ -2338,29 +2313,29 @@ PUBLIC void csoundAddSpinSample(CSOUND *csound, int frame,
                                 int channel, MYFLT sample)
 {
 
-    int index = (frame * csound->inchnls) + channel;
-    csound->spin[index] += sample;
+  int index = (frame * csound->inchnls) + channel;
+  csound->spin[index] += sample;
 }
 
 PUBLIC MYFLT *csoundGetSpout(CSOUND *csound)
 {
-    return csound->spout;
+  return csound->spout;
 }
 
 PUBLIC MYFLT csoundGetSpoutSample(CSOUND *csound, int frame, int channel)
 {
-    int index = (frame * csound->nchnls) + channel;
-    return csound->spout[index];
+  int index = (frame * csound->nchnls) + channel;
+  return csound->spout[index];
 }
 
 PUBLIC const char *csoundGetOutputName(CSOUND *csound)
 {
-    return (const char*) csound->oparms_.outfilename;
+  return (const char*) csound->oparms_.outfilename;
 }
 
 PUBLIC const char *csoundGetInputName(CSOUND *csound)
 {
-    return (const char*) csound->oparms_.infilename;
+  return (const char*) csound->oparms_.infilename;
 }
 
 /**
@@ -2375,21 +2350,21 @@ PUBLIC const char *csoundGetInputName(CSOUND *csound)
 PUBLIC void csoundSetHostImplementedAudioIO(CSOUND *csound,
                                             int state, int bufSize)
 {
-    csound->enableHostImplementedAudioIO = state;
-    csound->hostRequestedBufferSize = (bufSize > 0 ? bufSize : 0);
+  csound->enableHostImplementedAudioIO = state;
+  csound->hostRequestedBufferSize = (bufSize > 0 ? bufSize : 0);
 }
 
 PUBLIC void csoundSetHostImplementedMIDIIO(CSOUND *csound,
-                                            int state)
+                                           int state)
 {
-    csound->enableHostImplementedMIDIIO = state;
+  csound->enableHostImplementedMIDIIO = state;
 }
 
 PUBLIC double csoundGetScoreTime(CSOUND *csound)
 {
-    double curtime = csound->icurTime;
-    double esr = csound->esr;
-    return curtime/esr;
+  double curtime = csound->icurTime;
+  double esr = csound->esr;
+  return curtime/esr;
 }
 
 /*
@@ -2398,46 +2373,46 @@ PUBLIC double csoundGetScoreTime(CSOUND *csound)
 
 PUBLIC int csoundIsScorePending(CSOUND *csound)
 {
-    return csound->csoundIsScorePending_;
+  return csound->csoundIsScorePending_;
 }
 
 PUBLIC void csoundSetScorePending(CSOUND *csound, int pending)
 {
-    csound->csoundIsScorePending_ = pending;
+  csound->csoundIsScorePending_ = pending;
 }
 
 PUBLIC void csoundSetScoreOffsetSeconds(CSOUND *csound, MYFLT offset)
 {
-    double  aTime;
-    MYFLT   prv = (MYFLT) csound->csoundScoreOffsetSeconds_;
+  double  aTime;
+  MYFLT   prv = (MYFLT) csound->csoundScoreOffsetSeconds_;
 
-    csound->csoundScoreOffsetSeconds_ = offset;
-    if (offset < FL(0.0))
-      return;
-    /* if csoundCompile() was not called yet, just store the offset */
-    if (!(csound->engineStatus & CS_STATE_COMP))
-      return;
-    /* otherwise seek to the requested time now */
-    aTime = (double) offset - (csound->icurTime/csound->esr);
-    if (aTime < 0.0 || offset < prv) {
-      csoundRewindScore(csound);    /* will call csoundSetScoreOffsetSeconds */
-      return;
-    }
-    if (aTime > 0.0) {
-      EVTBLK  evt;
-      memset(&evt, 0, sizeof(EVTBLK));
-      evt.strarg = NULL; evt.scnt = 0;
-      evt.opcod = 'a';
-      evt.pcnt = 3;
-      evt.p[2] = evt.p[1] = FL(0.0);
-      evt.p[3] = (MYFLT) aTime;
-      insert_score_event_at_sample(csound, &evt, csound->icurTime);
-    }
+  csound->csoundScoreOffsetSeconds_ = offset;
+  if (offset < FL(0.0))
+    return;
+  /* if csoundCompile() was not called yet, just store the offset */
+  if (!(csound->engineStatus & CS_STATE_COMP))
+    return;
+  /* otherwise seek to the requested time now */
+  aTime = (double) offset - (csound->icurTime/csound->esr);
+  if (aTime < 0.0 || offset < prv) {
+    csoundRewindScore(csound);    /* will call csoundSetScoreOffsetSeconds */
+    return;
+  }
+  if (aTime > 0.0) {
+    EVTBLK  evt;
+    memset(&evt, 0, sizeof(EVTBLK));
+    evt.strarg = NULL; evt.scnt = 0;
+    evt.opcod = 'a';
+    evt.pcnt = 3;
+    evt.p[2] = evt.p[1] = FL(0.0);
+    evt.p[3] = (MYFLT) aTime;
+    insert_score_event_at_sample(csound, &evt, csound->icurTime);
+  }
 }
 
 PUBLIC MYFLT csoundGetScoreOffsetSeconds(CSOUND *csound)
 {
-    return csound->csoundScoreOffsetSeconds_;
+  return csound->csoundScoreOffsetSeconds_;
 }
 
 extern void musmon_rewind_score(CSOUND *csound);      /* musmon.c */
@@ -2445,94 +2420,94 @@ extern void midifile_rewind_score(CSOUND *csound);    /* midifile.c */
 
 PUBLIC void csoundRewindScore(CSOUND *csound)
 {
-    musmon_rewind_score(csound);
-    if (csound->oparms->FMidiname != NULL) midifile_rewind_score(csound);
+  musmon_rewind_score(csound);
+  if (csound->oparms->FMidiname != NULL) midifile_rewind_score(csound);
 }
 
 PUBLIC void csoundSetCscoreCallback(CSOUND *p,
                                     void (*cscoreCallback)(CSOUND *))
 {
-    p->cscoreCallback_ = (cscoreCallback != NULL ? cscoreCallback : cscore_);
+  p->cscoreCallback_ = (cscoreCallback != NULL ? cscoreCallback : cscore_);
 }
 
 static void csoundDefaultMessageCallback(CSOUND *csound, int attr,
                                          const char *format, va_list args)
 {
 #if defined(WIN32)
-    switch (attr & CSOUNDMSG_TYPE_MASK) {
-    case CSOUNDMSG_ERROR:
-    case CSOUNDMSG_WARNING:
-    case CSOUNDMSG_REALTIME:
-      vfprintf(stderr, format, args);
-      break;
-    default:
-      vfprintf(stdout, format, args);
-    }
+  switch (attr & CSOUNDMSG_TYPE_MASK) {
+  case CSOUNDMSG_ERROR:
+  case CSOUNDMSG_WARNING:
+  case CSOUNDMSG_REALTIME:
+    vfprintf(stderr, format, args);
+    break;
+  default:
+    vfprintf(stdout, format, args);
+  }
 #else
-    FILE *fp = stderr;
-    if ((attr & CSOUNDMSG_TYPE_MASK) == CSOUNDMSG_STDOUT)
-      fp = stdout;
-    if (!attr || !csound->enableMsgAttr) {
-      vfprintf(fp, format, args);
-      return;
-    }
-    if ((attr & CSOUNDMSG_TYPE_MASK) == CSOUNDMSG_ORCH)
-      if (attr & CSOUNDMSG_BG_COLOR_MASK)
-        fprintf(fp, "\033[4%cm", ((attr & 0x70) >> 4) + '0');
-    if (attr & CSOUNDMSG_FG_ATTR_MASK) {
-      if (attr & CSOUNDMSG_FG_BOLD)
-        fprintf(fp, "\033[1m");
-      if (attr & CSOUNDMSG_FG_UNDERLINE)
-        fprintf(fp, "\033[4m");
-    }
-    if (attr & CSOUNDMSG_FG_COLOR_MASK)
-      fprintf(fp, "\033[3%cm", (attr & 7) + '0');
+  FILE *fp = stderr;
+  if ((attr & CSOUNDMSG_TYPE_MASK) == CSOUNDMSG_STDOUT)
+    fp = stdout;
+  if (!attr || !csound->enableMsgAttr) {
     vfprintf(fp, format, args);
-    fprintf(fp, "\033[m");
+    return;
+  }
+  if ((attr & CSOUNDMSG_TYPE_MASK) == CSOUNDMSG_ORCH)
+    if (attr & CSOUNDMSG_BG_COLOR_MASK)
+      fprintf(fp, "\033[4%cm", ((attr & 0x70) >> 4) + '0');
+  if (attr & CSOUNDMSG_FG_ATTR_MASK) {
+    if (attr & CSOUNDMSG_FG_BOLD)
+      fprintf(fp, "\033[1m");
+    if (attr & CSOUNDMSG_FG_UNDERLINE)
+      fprintf(fp, "\033[4m");
+  }
+  if (attr & CSOUNDMSG_FG_COLOR_MASK)
+    fprintf(fp, "\033[3%cm", (attr & 7) + '0');
+  vfprintf(fp, format, args);
+  fprintf(fp, "\033[m");
 #endif
 }
 
 PUBLIC void csoundSetDefaultMessageCallback(
-           void (*csoundMessageCallback)(CSOUND *csound,
-                                         int attr,
-                                         const char *format,
-                                         va_list args))
+                                            void (*csoundMessageCallback)(CSOUND *csound,
+                                                                          int attr,
+                                                                          const char *format,
+                                                                          va_list args))
 {
-    if (csoundMessageCallback) {
-      msgcallback_ = csoundMessageCallback;
-    } else {
-      msgcallback_ = csoundDefaultMessageCallback;
-    }
+  if (csoundMessageCallback) {
+    msgcallback_ = csoundMessageCallback;
+  } else {
+    msgcallback_ = csoundDefaultMessageCallback;
+  }
 }
 
 
 
 PUBLIC void csoundSetMessageStringCallback(CSOUND *csound,
-              void (*csoundMessageStrCallback)(CSOUND *csound,
-                                            int attr,
-                                            const char *str)) {
+                                           void (*csoundMessageStrCallback)(CSOUND *csound,
+                                                                            int attr,
+                                                                            const char *str)) {
 
   if (csoundMessageStrCallback) {
     if(csound->message_string == NULL)
       csound->message_string = (char *) csound->Calloc(csound, MAX_MESSAGE_STR);
-  csound->csoundMessageStringCallback = csoundMessageStrCallback;
-  csound->csoundMessageCallback_ = NULL;
+    csound->csoundMessageStringCallback = csoundMessageStrCallback;
+    csound->csoundMessageCallback_ = NULL;
   }
 
 }
 
 PUBLIC void csoundSetMessageCallback(CSOUND *csound,
-            void (*csoundMessageCallback)(CSOUND *csound,
-                                          int attr,
-                                          const char *format,
-                                          va_list args))
-{
-    /* Protect against a null callback. */
-    if (csoundMessageCallback) {
-      csound->csoundMessageCallback_ = csoundMessageCallback;
-    } else {
-      csound->csoundMessageCallback_ = csoundDefaultMessageCallback;
-    }
+                                     void (*csoundMessageCallback)(CSOUND *csound,
+                                                                   int attr,
+                                                                   const char *format,
+                                                                   va_list args))
+{
+  /* Protect against a null callback. */
+  if (csoundMessageCallback) {
+    csound->csoundMessageCallback_ = csoundMessageCallback;
+  } else {
+    csound->csoundMessageCallback_ = csoundDefaultMessageCallback;
+  }
 }
 
 PUBLIC void csoundMessageV(CSOUND *csound,
@@ -2548,114 +2523,114 @@ PUBLIC void csoundMessageV(CSOUND *csound,
 
 PUBLIC void csoundMessage(CSOUND *csound, const char *format, ...)
 {
-    va_list args;
-    va_start(args, format);
-    if(csound->csoundMessageCallback_)
+  va_list args;
+  va_start(args, format);
+  if(csound->csoundMessageCallback_)
     csound->csoundMessageCallback_(csound, 0, format, args);
-    else {
+  else {
     vsnprintf(csound->message_string, MAX_MESSAGE_STR, format, args);
     csound->csoundMessageStringCallback(csound, 0, csound->message_string);
-    }
-    va_end(args);
+  }
+  va_end(args);
 }
 
 PUBLIC void csoundMessageS(CSOUND *csound, int attr, const char *format, ...)
 {
-    va_list args;
-    va_start(args, format);
-    if(csound->csoundMessageCallback_)
+  va_list args;
+  va_start(args, format);
+  if(csound->csoundMessageCallback_)
     csound->csoundMessageCallback_(csound, attr, format, args);
-    else {
+  else {
     vsnprintf(csound->message_string, MAX_MESSAGE_STR, format, args);
     csound->csoundMessageStringCallback(csound, attr, csound->message_string);
-    }
-    va_end(args);
+  }
+  va_end(args);
 }
 
 void csoundDie(CSOUND *csound, const char *msg, ...)
 {
-    va_list args;
-    va_start(args, msg);
-    csound->ErrMsgV(csound, (char*) 0, msg, args);
-    va_end(args);
-    csound->perferrcnt++;
-    csound->LongJmp(csound, 1);
+  va_list args;
+  va_start(args, msg);
+  csound->ErrMsgV(csound, (char*) 0, msg, args);
+  va_end(args);
+  csound->perferrcnt++;
+  /* csound->LongJmp(csound, 1); */
 }
 
 void csoundWarning(CSOUND *csound, const char *msg, ...)
 {
-    va_list args;
-    if (!(csound->oparms_.msglevel & WARNMSG))
-      return;
-    csoundMessageS(csound, CSOUNDMSG_WARNING, Str("WARNING: "));
-    va_start(args, msg);
-    csoundMessageV(csound, CSOUNDMSG_WARNING, msg, args);
-    va_end(args);
-    csoundMessageS(csound, CSOUNDMSG_WARNING, "\n");
+  va_list args;
+  if (!(csound->oparms_.msglevel & WARNMSG))
+    return;
+  csoundMessageS(csound, CSOUNDMSG_WARNING, Str("WARNING: "));
+  va_start(args, msg);
+  csoundMessageV(csound, CSOUNDMSG_WARNING, msg, args);
+  va_end(args);
+  csoundMessageS(csound, CSOUNDMSG_WARNING, "\n");
 }
 
 void csoundDebugMsg(CSOUND *csound, const char *msg, ...)
 {
-    va_list args;
-    if (!(csound->oparms_.odebug))
-      return;
-    va_start(args, msg);
-    csoundMessageV(csound, 0, msg, args);
-    va_end(args);
-    csoundMessage(csound, "\n");
+  va_list args;
+  if (!(csound->oparms_.odebug))
+    return;
+  va_start(args, msg);
+  csoundMessageV(csound, 0, msg, args);
+  va_end(args);
+  csoundMessage(csound, "\n");
 }
 
 void csoundErrorMsg(CSOUND *csound, const char *msg, ...)
 {
-    va_list args;
-    va_start(args, msg);
-    csoundMessageV(csound, CSOUNDMSG_ERROR, msg, args);
-    va_end(args);
-    csound->MessageS(csound, CSOUNDMSG_ERROR, "\n");
+  va_list args;
+  va_start(args, msg);
+  csoundMessageV(csound, CSOUNDMSG_ERROR, msg, args);
+  va_end(args);
+  csound->MessageS(csound, CSOUNDMSG_ERROR, "\n");
 }
 
 void csoundErrMsgV(CSOUND *csound,
                    const char *hdr, const char *msg, va_list args)
 {
-    if (hdr != NULL)
-      csound->MessageS(csound, CSOUNDMSG_ERROR, "%s", hdr);
-    csoundMessageV(csound, CSOUNDMSG_ERROR, msg, args);
-    csound->MessageS(csound, CSOUNDMSG_ERROR, "\n");
+  if (hdr != NULL)
+    csound->MessageS(csound, CSOUNDMSG_ERROR, "%s", hdr);
+  csoundMessageV(csound, CSOUNDMSG_ERROR, msg, args);
+  csound->MessageS(csound, CSOUNDMSG_ERROR, "\n");
 }
 
 void csoundLongJmp(CSOUND *csound, int retval)
 {
-    int   n = CSOUND_EXITJMP_SUCCESS;
+  int   n = CSOUND_EXITJMP_SUCCESS;
 
-    n = (retval < 0 ? n + retval : n - retval) & (CSOUND_EXITJMP_SUCCESS - 1);
-    //printf("**** n = %d\n", n);
-    if (!n)
-      n = CSOUND_EXITJMP_SUCCESS;
+  n = (retval < 0 ? n + retval : n - retval) & (CSOUND_EXITJMP_SUCCESS - 1);
+  //printf("**** n = %d\n", n);
+  if (!n)
+    n = CSOUND_EXITJMP_SUCCESS;
 
-    csound->curip = NULL;
-    csound->ids = NULL;
-    csound->reinitflag = 0;
-    csound->tieflag = 0;
-    csound->perferrcnt += csound->inerrcnt;
-    csound->inerrcnt = 0;
-    csound->engineStatus |= CS_STATE_JMP;
-    //printf("**** longjmp with %d\n", n);
-    longjmp(csound->exitjmp, n);
+  csound->curip = NULL;
+  csound->ids = NULL;
+  csound->reinitflag = 0;
+  csound->tieflag = 0;
+  csound->perferrcnt += csound->inerrcnt;
+  csound->inerrcnt = 0;
+  csound->engineStatus |= CS_STATE_JMP;
+  //printf("**** longjmp with %d\n", n);
+  /* longjmp(csound->exitjmp, n); */
 }
 
 PUBLIC void csoundSetMessageLevel(CSOUND *csound, int messageLevel)
 {
-    csound->oparms_.msglevel = messageLevel;
+  csound->oparms_.msglevel = messageLevel;
 }
 
 PUBLIC int csoundGetMessageLevel(CSOUND *csound)
 {
-    return csound->oparms_.msglevel;
+  return csound->oparms_.msglevel;
 }
 
 PUBLIC void csoundKeyPress(CSOUND *csound, char c)
 {
-    csound->inChar_ = (int) ((unsigned char) c);
+  csound->inChar_ = (int) ((unsigned char) c);
 }
 
 /*
@@ -2666,49 +2641,49 @@ PUBLIC void
 csoundSetInputChannelCallback(CSOUND *csound,
                               channelCallback_t inputChannelCalback)
 {
-    csound->InputChannelCallback_ = inputChannelCalback;
+  csound->InputChannelCallback_ = inputChannelCalback;
 }
 
 PUBLIC void
 csoundSetOutputChannelCallback(CSOUND *csound,
                                channelCallback_t outputChannelCalback)
 {
-    csound->OutputChannelCallback_ = outputChannelCalback;
+  csound->OutputChannelCallback_ = outputChannelCalback;
 }
 
 int csoundScoreEventInternal(CSOUND *csound, char type,
-                            const MYFLT *pfields, long numFields)
+                             const MYFLT *pfields, long numFields)
 {
-    EVTBLK  evt;
-    int     i;
-    int ret;
-    memset(&evt, 0, sizeof(EVTBLK));
+  EVTBLK  evt;
+  int     i;
+  int ret;
+  memset(&evt, 0, sizeof(EVTBLK));
 
-    evt.strarg = NULL; evt.scnt = 0;
-    evt.opcod = type;
-    evt.pcnt = (int16) numFields;
-    for (i = 0; i < (int) numFields; i++)
-      evt.p[i + 1] = pfields[i];
-    ret = insert_score_event_at_sample(csound, &evt, csound->icurTime);
-    return ret;
+  evt.strarg = NULL; evt.scnt = 0;
+  evt.opcod = type;
+  evt.pcnt = (int16) numFields;
+  for (i = 0; i < (int) numFields; i++)
+    evt.p[i + 1] = pfields[i];
+  ret = insert_score_event_at_sample(csound, &evt, csound->icurTime);
+  return ret;
 }
 
 int csoundScoreEventAbsoluteInternal(CSOUND *csound, char type,
-                                    const MYFLT *pfields, long numFields,
-                                    double time_ofs)
+                                     const MYFLT *pfields, long numFields,
+                                     double time_ofs)
 {
-    EVTBLK  evt;
-    int     i;
-    int     ret;
-    memset(&evt, 0, sizeof(EVTBLK));
+  EVTBLK  evt;
+  int     i;
+  int     ret;
+  memset(&evt, 0, sizeof(EVTBLK));
 
-    evt.strarg = NULL; evt.scnt = 0;
-    evt.opcod = type;
-    evt.pcnt = (int16) numFields;
-    for (i = 0; i < (int) numFields; i++)
-      evt.p[i + 1] = pfields[i];
-    ret = insert_score_event(csound, &evt, time_ofs);
-    return ret;
+  evt.strarg = NULL; evt.scnt = 0;
+  evt.opcod = type;
+  evt.pcnt = (int16) numFields;
+  for (i = 0; i < (int) numFields; i++)
+    evt.p[i + 1] = pfields[i];
+  ret = insert_score_event(csound, &evt, time_ofs);
+  return ret;
 }
 
 /*
@@ -2719,118 +2694,118 @@ int csoundScoreEventAbsoluteInternal(CSOUND *csound, char type,
 
 static double *get_dummy_rtaudio_globals(CSOUND *csound)
 {
-    double  *p;
+  double  *p;
 
+  p = (double*) csound->QueryGlobalVariable(csound, "__rtaudio_null_state");
+  if (p == NULL) {
+    if (UNLIKELY(csound->CreateGlobalVariable(csound, "__rtaudio_null_state",
+                                              sizeof(double) * 4) != 0))
+      csound->Die(csound, Str("rtdummy: failed to allocate globals"));
+    csound->Message(csound, Str("rtaudio: dummy module enabled\n"));
     p = (double*) csound->QueryGlobalVariable(csound, "__rtaudio_null_state");
-    if (p == NULL) {
-      if (UNLIKELY(csound->CreateGlobalVariable(csound, "__rtaudio_null_state",
-                                                sizeof(double) * 4) != 0))
-        csound->Die(csound, Str("rtdummy: failed to allocate globals"));
-      csound->Message(csound, Str("rtaudio: dummy module enabled\n"));
-      p = (double*) csound->QueryGlobalVariable(csound, "__rtaudio_null_state");
-    }
-    return p;
+  }
+  return p;
 }
 
 static void dummy_rtaudio_timer(CSOUND *csound, double *p)
 {
-    double  timeWait;
-    int     i;
+  double  timeWait;
+  int     i;
 
-    timeWait = p[0] - csoundGetRealTime(csound->csRtClock);
-    i = (int) (timeWait * 1000.0 + 0.5);
-    if (i > 0)
-      csoundSleep((size_t) i);
+  timeWait = p[0] - csoundGetRealTime(csound->csRtClock);
+  i = (int) (timeWait * 1000.0 + 0.5);
+  if (i > 0)
+    csoundSleep((size_t) i);
 }
 
 int playopen_dummy(CSOUND *csound, const csRtAudioParams *parm)
 {
-    double  *p;
-    char    *s;
+  double  *p;
+  char    *s;
 
-    /* find out if the use of dummy real-time audio functions was requested, */
-    /* or an unknown plugin name was specified; the latter case is an error  */
-    s = (char*) csoundQueryGlobalVariable(csound, "_RTAUDIO");
-    if (s != NULL && !(strcmp(s, "null") == 0 || strcmp(s, "Null") == 0 ||
-                       strcmp(s, "NULL") == 0)) {
-      if (s[0] == '\0')
-        csoundErrorMsg(csound,
-                       Str(" *** error: rtaudio module set to empty string"));
-      else {
-        // print_opcodedir_warning(csound);
-        csoundErrorMsg(csound,
-                       Str(" unknown rtaudio module: '%s', using dummy module"),
-                       s);
-      }
-      // return CSOUND_ERROR;
+  /* find out if the use of dummy real-time audio functions was requested, */
+  /* or an unknown plugin name was specified; the latter case is an error  */
+  s = (char*) csoundQueryGlobalVariable(csound, "_RTAUDIO");
+  if (s != NULL && !(strcmp(s, "null") == 0 || strcmp(s, "Null") == 0 ||
+                     strcmp(s, "NULL") == 0)) {
+    if (s[0] == '\0')
+      csoundErrorMsg(csound,
+                     Str(" *** error: rtaudio module set to empty string"));
+    else {
+      // print_opcodedir_warning(csound);
+      csoundErrorMsg(csound,
+                     Str(" unknown rtaudio module: '%s', using dummy module"),
+                     s);
     }
-    p = get_dummy_rtaudio_globals(csound);
-    csound->rtPlay_userdata = (void*) p;
-    p[0] = csound->GetRealTime(csound->csRtClock);
-    p[1] = 1.0 / ((double) ((int) sizeof(MYFLT) * parm->nChannels)
-                  * (double) parm->sampleRate);
-    return CSOUND_SUCCESS;
+    // return CSOUND_ERROR;
+  }
+  p = get_dummy_rtaudio_globals(csound);
+  csound->rtPlay_userdata = (void*) p;
+  p[0] = csound->GetRealTime(csound->csRtClock);
+  p[1] = 1.0 / ((double) ((int) sizeof(MYFLT) * parm->nChannels)
+                * (double) parm->sampleRate);
+  return CSOUND_SUCCESS;
 }
 
 void rtplay_dummy(CSOUND *csound, const MYFLT *outBuf, int nbytes)
 {
-    double  *p = (double*) csound->rtPlay_userdata;
-    (void) outBuf;
-    p[0] += ((double) nbytes * p[1]);
-    dummy_rtaudio_timer(csound, p);
+  double  *p = (double*) csound->rtPlay_userdata;
+  (void) outBuf;
+  p[0] += ((double) nbytes * p[1]);
+  dummy_rtaudio_timer(csound, p);
 }
 
 int recopen_dummy(CSOUND *csound, const csRtAudioParams *parm)
 {
-    double  *p;
-    char    *s;
+  double  *p;
+  char    *s;
 
-    /* find out if the use of dummy real-time audio functions was requested, */
-    /* or an unknown plugin name was specified; the latter case is an error  */
-    s = (char*) csoundQueryGlobalVariable(csound, "_RTAUDIO");
-    if (s != NULL && !(strcmp(s, "null") == 0 || strcmp(s, "Null") == 0 ||
-                       strcmp(s, "NULL") == 0)) {
-      if (s[0] == '\0')
-        csoundErrorMsg(csound,
-                       Str(" *** error: rtaudio module set to empty string"));
-      else {
-        // print_opcodedir_warning(csound);
-        csoundErrorMsg(csound,
-                       Str(" unknown rtaudio module: '%s', using dummy module"),
-                       s);
-      }
-      // return CSOUND_ERROR;
+  /* find out if the use of dummy real-time audio functions was requested, */
+  /* or an unknown plugin name was specified; the latter case is an error  */
+  s = (char*) csoundQueryGlobalVariable(csound, "_RTAUDIO");
+  if (s != NULL && !(strcmp(s, "null") == 0 || strcmp(s, "Null") == 0 ||
+                     strcmp(s, "NULL") == 0)) {
+    if (s[0] == '\0')
+      csoundErrorMsg(csound,
+                     Str(" *** error: rtaudio module set to empty string"));
+    else {
+      // print_opcodedir_warning(csound);
+      csoundErrorMsg(csound,
+                     Str(" unknown rtaudio module: '%s', using dummy module"),
+                     s);
     }
-    p = (double*) get_dummy_rtaudio_globals(csound) + 2;
-    csound->rtRecord_userdata = (void*) p;
-    p[0] = csound->GetRealTime(csound->csRtClock);
-    p[1] = 1.0 / ((double) ((int) sizeof(MYFLT) * parm->nChannels)
-                  * (double) parm->sampleRate);
-    return CSOUND_SUCCESS;
+    // return CSOUND_ERROR;
+  }
+  p = (double*) get_dummy_rtaudio_globals(csound) + 2;
+  csound->rtRecord_userdata = (void*) p;
+  p[0] = csound->GetRealTime(csound->csRtClock);
+  p[1] = 1.0 / ((double) ((int) sizeof(MYFLT) * parm->nChannels)
+                * (double) parm->sampleRate);
+  return CSOUND_SUCCESS;
 }
 
 int rtrecord_dummy(CSOUND *csound, MYFLT *inBuf, int nbytes)
 {
-    double  *p = (double*) csound->rtRecord_userdata;
+  double  *p = (double*) csound->rtRecord_userdata;
 
-    /* for (i = 0; i < (nbytes / (int) sizeof(MYFLT)); i++) */
-    /*   ((MYFLT*) inBuf)[i] = FL(0.0); */
-    memset(inBuf, 0, nbytes);
+  /* for (i = 0; i < (nbytes / (int) sizeof(MYFLT)); i++) */
+  /*   ((MYFLT*) inBuf)[i] = FL(0.0); */
+  memset(inBuf, 0, nbytes);
 
-    p[0] += ((double) nbytes * p[1]);
-    dummy_rtaudio_timer(csound, p);
+  p[0] += ((double) nbytes * p[1]);
+  dummy_rtaudio_timer(csound, p);
 
-    return nbytes;
+  return nbytes;
 }
 
 void rtclose_dummy(CSOUND *csound)
 {
-    csound->rtPlay_userdata = NULL;
-    csound->rtRecord_userdata = NULL;
+  csound->rtPlay_userdata = NULL;
+  csound->rtRecord_userdata = NULL;
 }
 
 int  audio_dev_list_dummy(CSOUND *csound,
-                                 CS_AUDIODEVICE *list, int isOutput)
+                          CS_AUDIODEVICE *list, int isOutput)
 {
   IGN(csound); IGN(list); IGN(isOutput);
   return 0;
@@ -2846,7 +2821,7 @@ PUBLIC void csoundSetPlayopenCallback(CSOUND *csound,
                                                         const csRtAudioParams
                                                         *parm))
 {
-    csound->playopen_callback = playopen__;
+  csound->playopen_callback = playopen__;
 }
 
 PUBLIC void csoundSetRtplayCallback(CSOUND *csound,
@@ -2854,14 +2829,14 @@ PUBLIC void csoundSetRtplayCallback(CSOUND *csound,
                                                      const MYFLT *outBuf,
                                                      int nbytes))
 {
-    csound->rtplay_callback = rtplay__;
+  csound->rtplay_callback = rtplay__;
 }
 
 PUBLIC void csoundSetRecopenCallback(CSOUND *csound,
                                      int (*recopen__)(CSOUND *,
                                                       const csRtAudioParams *parm))
 {
-    csound->recopen_callback = recopen__;
+  csound->recopen_callback = recopen__;
 }
 
 PUBLIC void csoundSetRtrecordCallback(CSOUND *csound,
@@ -2869,25 +2844,25 @@ PUBLIC void csoundSetRtrecordCallback(CSOUND *csound,
                                                         MYFLT *inBuf,
                                                         int nbytes))
 {
-    csound->rtrecord_callback = rtrecord__;
+  csound->rtrecord_callback = rtrecord__;
 }
 
 PUBLIC void csoundSetRtcloseCallback(CSOUND *csound,
                                      void (*rtclose__)(CSOUND *))
 {
-    csound->rtclose_callback = rtclose__;
+  csound->rtclose_callback = rtclose__;
 }
 
 PUBLIC void csoundSetAudioDeviceListCallback(CSOUND *csound,
-            int (*audiodevlist__)(CSOUND *, CS_AUDIODEVICE *list, int isOutput))
+                                             int (*audiodevlist__)(CSOUND *, CS_AUDIODEVICE *list, int isOutput))
 {
-    csound->audio_dev_list_callback = audiodevlist__;
+  csound->audio_dev_list_callback = audiodevlist__;
 }
 
 PUBLIC void csoundSetMIDIDeviceListCallback(CSOUND *csound,
-            int (*mididevlist__)(CSOUND *, CS_MIDIDEVICE *list, int isOutput))
+                                            int (*mididevlist__)(CSOUND *, CS_MIDIDEVICE *list, int isOutput))
 {
-    csound->midi_dev_list_callback = mididevlist__;
+  csound->midi_dev_list_callback = mididevlist__;
 }
 
 PUBLIC int csoundGetAudioDevList(CSOUND *csound,
@@ -2903,70 +2878,70 @@ PUBLIC int csoundGetMIDIDevList(CSOUND *csound,  CS_MIDIDEVICE *list, int isOutp
 
 /* dummy real time MIDI functions */
 int DummyMidiInOpen(CSOUND *csound, void **userData,
-                           const char *devName)
-{
-    char *s;
-
-    (void) devName;
-    *userData = NULL;
-    s = (char*) csoundQueryGlobalVariable(csound, "_RTMIDI");
-    if (UNLIKELY(s == NULL ||
-        (strcmp(s, "null") == 0 || strcmp(s, "Null") == 0 ||
-         strcmp(s, "NULL") == 0))) {
-      csoundMessage(csound, Str("!!WARNING: real time midi input disabled, "
-                                "using dummy functions\n"));
-      return 0;
-    }
-    if (s[0] == '\0')
-      csoundErrorMsg(csound, Str("error: -+rtmidi set to empty string"));
-    else {
-      print_opcodedir_warning(csound);
-      csoundErrorMsg(csound, Str("error: -+rtmidi='%s': unknown module"), s);
-    }
-    return -1;
+                    const char *devName)
+{
+  char *s;
+
+  (void) devName;
+  *userData = NULL;
+  s = (char*) csoundQueryGlobalVariable(csound, "_RTMIDI");
+  if (UNLIKELY(s == NULL ||
+               (strcmp(s, "null") == 0 || strcmp(s, "Null") == 0 ||
+                strcmp(s, "NULL") == 0))) {
+    csoundMessage(csound, Str("!!WARNING: real time midi input disabled, "
+                              "using dummy functions\n"));
+    return 0;
+  }
+  if (s[0] == '\0')
+    csoundErrorMsg(csound, Str("error: -+rtmidi set to empty string"));
+  else {
+    print_opcodedir_warning(csound);
+    csoundErrorMsg(csound, Str("error: -+rtmidi='%s': unknown module"), s);
+  }
+  return -1;
 }
 
 int DummyMidiRead(CSOUND *csound, void *userData,
-                         unsigned char *buf, int nbytes)
+                  unsigned char *buf, int nbytes)
 {
-    (void) csound;
-    (void) userData;
-    (void) buf;
-    (void) nbytes;
-    return 0;
+  (void) csound;
+  (void) userData;
+  (void) buf;
+  (void) nbytes;
+  return 0;
 }
 
 int DummyMidiOutOpen(CSOUND *csound, void **userData,
-                            const char *devName)
-{
-    char *s;
-
-    (void) devName;
-    *userData = NULL;
-    s = (char*) csoundQueryGlobalVariable(csound, "_RTMIDI");
-    if (s == NULL ||
-        (strcmp(s, "null") == 0 || strcmp(s, "Null") == 0 ||
-         strcmp(s, "NULL") == 0)) {
-      csoundMessage(csound, Str("WARNING: real time midi output disabled, "
-                                "using dummy functions\n"));
-      return 0;
-    }
-    if (s[0] == '\0')
-      csoundErrorMsg(csound, Str("error: -+rtmidi set to empty string"));
-    else {
-      print_opcodedir_warning(csound);
-      csoundErrorMsg(csound, Str("error: -+rtmidi='%s': unknown module"), s);
-    }
-    return -1;
+                     const char *devName)
+{
+  char *s;
+
+  (void) devName;
+  *userData = NULL;
+  s = (char*) csoundQueryGlobalVariable(csound, "_RTMIDI");
+  if (s == NULL ||
+      (strcmp(s, "null") == 0 || strcmp(s, "Null") == 0 ||
+       strcmp(s, "NULL") == 0)) {
+    csoundMessage(csound, Str("WARNING: real time midi output disabled, "
+                              "using dummy functions\n"));
+    return 0;
+  }
+  if (s[0] == '\0')
+    csoundErrorMsg(csound, Str("error: -+rtmidi set to empty string"));
+  else {
+    print_opcodedir_warning(csound);
+    csoundErrorMsg(csound, Str("error: -+rtmidi='%s': unknown module"), s);
+  }
+  return -1;
 }
 
 int DummyMidiWrite(CSOUND *csound, void *userData,
-                          const unsigned char *buf, int nbytes)
+                   const unsigned char *buf, int nbytes)
 {
-    (void) csound;
-    (void) userData;
-    (void) buf;
-    return nbytes;
+  (void) csound;
+  (void) userData;
+  (void) buf;
+  return nbytes;
 }
 
 static const char *midi_err_msg = Str_noop("Unknown MIDI error");
@@ -2977,9 +2952,9 @@ static const char *midi_err_msg = Str_noop("Unknown MIDI error");
  */
 const char *csoundExternalMidiErrorString(CSOUND *csound, int errcode)
 {
-    if (csound->midiGlobals->MidiErrorStringCallback == NULL)
-      return midi_err_msg;
-    return (csound->midiGlobals->MidiErrorStringCallback(errcode));
+  if (csound->midiGlobals->MidiErrorStringCallback == NULL)
+    return midi_err_msg;
+  return (csound->midiGlobals->MidiErrorStringCallback(errcode));
 }
 
 /* Set real time MIDI function pointers. */
@@ -2989,7 +2964,7 @@ PUBLIC void csoundSetExternalMidiInOpenCallback(CSOUND *csound,
                                                             void **,
                                                             const char *))
 {
-    csound->midiGlobals->MidiInOpenCallback = func;
+  csound->midiGlobals->MidiInOpenCallback = func;
 }
 
 PUBLIC void csoundSetExternalMidiReadCallback(CSOUND *csound,
@@ -2997,7 +2972,7 @@ PUBLIC void csoundSetExternalMidiReadCallback(CSOUND *csound,
                                                           void *,
                                                           unsigned char *, int))
 {
-    csound->midiGlobals->MidiReadCallback = func;
+  csound->midiGlobals->MidiReadCallback = func;
 }
 
 PUBLIC void csoundSetExternalMidiInCloseCallback(CSOUND *csound,
@@ -3189,9 +3164,9 @@ void SetInternalYieldCallback(CSOUND *csound,
 
 int csoundYield(CSOUND *csound)
 {
-    if (exitNow_)
-      csound->LongJmp(csound, CSOUND_SIGNAL);
-    csound->csoundInternalYieldCallback_(csound);
+  /* if (exitNow_) */
+  /*   csound->LongJmp(csound, CSOUND_SIGNAL); */
+  csound->csoundInternalYieldCallback_(csound);
     return csound->csoundYieldCallback_(csound);
 }
 
@@ -3282,7 +3257,7 @@ static void reset(CSOUND *csound)
     csound->spinlock1= saved_env->spinlock1;
 #endif
     csound->enableHostImplementedMIDIIO = saved_env->enableHostImplementedMIDIIO;
-    memcpy(&(csound->exitjmp), &(saved_env->exitjmp), sizeof(jmp_buf));
+    /* memcpy(&(csound->exitjmp), &(saved_env->exitjmp), sizeof(jmp_buf)); */
     csound->memalloc_db = saved_env->memalloc_db;
     //csound->self = self;
     free(saved_env);
@@ -3306,8 +3281,8 @@ PUBLIC void csoundSetRTAudioModule(CSOUND *csound, const char *module){
       csound->SetAudioDeviceListCallback(csound, audio_dev_list_dummy);
       return;
   }
-   if (csoundInitModules(csound) != 0)
-             csound->LongJmp(csound, 1);
+    /* if (csoundInitModules(csound) != 0) */
+    /*           csound->LongJmp(csound, 1); */
 }
 
 
@@ -3329,8 +3304,8 @@ PUBLIC void csoundSetMIDIModule(CSOUND *csound, const char *module){
 
       return;
     }
-    if (csoundInitModules(csound) != 0)
-      csound->LongJmp(csound, 1);
+    /* if (csoundInitModules(csound) != 0) */
+    /*   csound->LongJmp(csound, 1); */
 }
 
 
@@ -3417,8 +3392,8 @@ PUBLIC void csoundReset(CSOUND *csound)
         csound->Die(csound, Str("Failed during csoundLoadModules"));
 
       /* VL: moved here from main.c */
-      if (csoundInitModules(csound) != 0)
-            csound->LongJmp(csound, 1);
+      /* if (csoundInitModules(csound) != 0) */
+      /*       csound->LongJmp(csound, 1); */
 
       init_pvsys(csound);
       /* utilities depend on this as well as orchs; may get changed by an orch */
@@ -4450,12 +4425,6 @@ PUBLIC int csoundPerformKsmpsAbsolute(CSOUND *csound)
       return CSOUND_ERROR;
     }
     /* setup jmp for return after an exit() */
-    if (UNLIKELY((returnValue = setjmp(csound->exitjmp)))) {
-#ifndef MACOSX
-      csoundMessage(csound, Str("Early return from csoundPerformKsmps().\n"));
-#endif
-      return ((returnValue - CSOUND_EXITJMP_SUCCESS) | CSOUND_EXITJMP_SUCCESS);
-    }
     csoundLockMutex(csound->API_lock);
     do {
       done |= sensevents(csound);
diff --git a/Top/main.c b/Top/main.c
index 1b7e9783c..13c2e5b9a 100644
--- a/Top/main.c
+++ b/Top/main.c
@@ -159,9 +159,6 @@ PUBLIC int csoundCompileArgs(CSOUND *csound, int argc, const char **argv)
     char    *fileDir;
 
 
-    if ((n = setjmp(csound->exitjmp)) != 0) {
-      return ((n - CSOUND_EXITJMP_SUCCESS) | CSOUND_EXITJMP_SUCCESS);
-    }
 
     argc = ac;
     if (UNLIKELY(csound->engineStatus & CS_STATE_COMP)) {
@@ -464,10 +461,6 @@ PUBLIC int csoundStart(CSOUND *csound) // DEBUG
       csoundCompileOrcInternal(csound, "idummy = 0\n", 0);
     }
 
-    if ((n = setjmp(csound->exitjmp)) != 0) {
-      return ((n - CSOUND_EXITJMP_SUCCESS) | CSOUND_EXITJMP_SUCCESS);
-    }
-
 
 
     /* if sound file type is still not known, check SFOUTYP */
diff --git a/Top/utility.c b/Top/utility.c
index 461ef760d..1922c0951 100644
--- a/Top/utility.c
+++ b/Top/utility.c
@@ -22,7 +22,6 @@
 */
 
 #include "csoundCore.h"
-#include <setjmp.h>
 #include "corfile.h"
 
 typedef struct csUtility_s {
@@ -70,21 +69,11 @@ PUBLIC int csoundRunUtility(CSOUND *csound, const char *name,
 {
     csUtility_t   *p;
     char          **lst;
-    volatile void *saved_exitjmp;
     volatile int  n;
 
     if (UNLIKELY(csound == NULL))
       return -1;
 
-    saved_exitjmp = (void*) csound->Malloc(csound, sizeof(jmp_buf));
-    if (UNLIKELY(saved_exitjmp == NULL))
-      return -1;
-    memcpy((void*) saved_exitjmp, (void*) &(csound->exitjmp), sizeof(jmp_buf));
-
-    if (UNLIKELY((n = setjmp(csound->exitjmp)) != 0)) {
-      n = (n - CSOUND_EXITJMP_SUCCESS) | CSOUND_EXITJMP_SUCCESS;
-      goto err_return;
-    }
 
     if (UNLIKELY(name == NULL || name[0] == '\0'))
       goto notFound;
@@ -124,8 +113,6 @@ PUBLIC int csoundRunUtility(CSOUND *csound, const char *name,
     csoundDeleteUtilityList(csound, lst);
     n = -1;
  err_return:
-    memcpy((void*) &(csound->exitjmp), (void*) saved_exitjmp, sizeof(jmp_buf));
-    csound->Free(csound, (void*) saved_exitjmp);
     return n;
 }
 
@@ -248,9 +235,7 @@ PUBLIC int csoundScoreSort(CSOUND *csound, FILE *inFile, FILE *outFile)
     int   err;
     CORFIL *inf = corfile_create_w(csound);
     int c;
-    if ((err = setjmp(csound->exitjmp)) != 0) {
-      return ((err - CSOUND_EXITJMP_SUCCESS) | CSOUND_EXITJMP_SUCCESS);
-    }
+
     while ((c=getc(inFile))!=EOF) corfile_putc(csound, c, inf);
     corfile_puts(csound, "\ne\n#exit\n", inf);
     corfile_rewind(inf);
@@ -276,9 +261,7 @@ PUBLIC int csoundScoreExtract(CSOUND *csound,
     int   err;
     CORFIL *inf = corfile_create_w(csound);
     int c;
-    if ((err = setjmp(csound->exitjmp)) != 0) {
-      return ((err - CSOUND_EXITJMP_SUCCESS) | CSOUND_EXITJMP_SUCCESS);
-    }
+
     while ((c=getc(inFile))!=EOF) corfile_putc(csound, c, inf);
     corfile_rewind(inf);
     scxtract(csound, inf, extractFile);
diff --git a/include/csoundCore.h b/include/csoundCore.h
index 633fe509e..b5d323f01 100644
--- a/include/csoundCore.h
+++ b/include/csoundCore.h
@@ -40,7 +40,6 @@
 #endif
 #include "cs_par_structs.h"
 #include <stdarg.h>
-#include <setjmp.h>
 #include "csound_type_system.h"
 #include "csound.h"
 #include "cscore.h"
@@ -1527,7 +1526,7 @@ typedef struct _message_queue_t_ {
     double        A4;
     void          *rtRecord_userdata;
     void          *rtPlay_userdata;
-    jmp_buf       exitjmp;
+    void*         exitjmp;
     SRTBLK        *frstbp;
     int           sectcnt;
     int           inerrcnt, synterrcnt, perferrcnt;
